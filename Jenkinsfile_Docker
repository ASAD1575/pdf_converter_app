pipeline {
    agent any

    environment {
        AWS_ACCOUNT_ID = '375299695019'
        AWS_DEFAULT_REGION = 'us-east-1'
        APP_SOURCE_PATH = 'pdf_converter_FastAPI_app/'
        TF_PATH = '.'
        APP_ZIP = "app_package.zip"
        LAYER_ZIP = "dependencies_layer.zip"
        S3_BUCKET = "pdflambdabucket1575"
    }

    stages {
        stage('Initialize Variables') {
            steps {
                script {
                    env.hostUserId = sh(returnStdout: true, script: 'id -u').trim()
                    env.hostGroupId = sh(returnStdout: true, script: 'id -g').trim()
                    echo "Jenkins user/group ID: ${env.hostUserId}:${env.hostGroupId}"
                }
            }
        }

        stage('Checkout Source') {
            steps {
                echo 'Checking out source code...'
                checkout scm
            }
        }

        stage('Build Lambda Packages') {
            agent {
                docker {
                    image 'python:3.12-slim'
                    args '--user 0 --entrypoint=""'
                }
            }
            steps {
                sh '''
                apt-get update && apt-get install zip -y

                rm -f $APP_ZIP $LAYER_ZIP
                rm -rf build
                mkdir -p build/app build/dependencies/python
                ls -l

                # Build app zip
                cp -r pdf_converter_FastAPI_app/main.py \
                    pdf_converter_FastAPI_app/database.py \
                    pdf_converter_FastAPI_app/models.py \
                    pdf_converter_FastAPI_app/utils.py \
                    pdf_converter_FastAPI_app/templates \
                    build/app/
                
                cd build/app && zip -r ../../$APP_ZIP . && cd ../..

                # Build dependencies layer zip
                pip install -r pdf_converter_FastAPI_app/requirements.txt -t build/dependencies/python/
                cd build/dependencies && zip -r ../../$LAYER_ZIP . && cd ../..

                # Change OwnerShip of the zip files
                chown ${hostUserId}:${hostGroupId} $APP_ZIP
                chown ${hostUserId}:${hostGroupId} $LAYER_ZIP
                '''

                // Pass the zip files to the next stage
                stash includes: "${APP_ZIP}", name: 'app-code'
                stash includes: "${LAYER_ZIP}", name: 'dependencies-layer'
            }
        }

        stage('Terraform Deploy') {
            agent {
                docker {
                    image 'hashicorp/terraform:1.5.7'
                    args '--user 0 --entrypoint="" --dns 8.8.8.8'
                }
            }
            steps {
                script {
                    withCredentials([
                        string(credentialsId: 'AWS_ACCESS_KEY_ID', variable: 'AWS_ACCESS_KEY_ID'),
                        string(credentialsId: 'AWS_SECRET_ACCESS_KEY', variable: 'AWS_SECRET_ACCESS_KEY')
                    ]) {

                        // Get the zip files from the previous stage
                        unstash 'app-code'
                        unstash 'dependencies-layer'

                        dir(env.TF_PATH) {

                            echo 'Installing Python & Dependencies in Terraform Environment...'
                            sh 'apk add --no-cache python3 py3-pip coreutils'
                            sh 'pip install awscli'

                            def fileHashApp = sh(returnStdout: true, script: "sha256sum ${APP_ZIP} | awk '{print \$1}'").trim()
                            def fileHashLayer = sh(returnStdout: true, script: "sha256sum ${LAYER_ZIP} | awk '{print \$1}'").trim()

                            echo "${fileHashApp}"
                            echo "${fileHashLayer}"

                            // Copying the zip files to the S3_BUCKET
                            echo 'Copying the zip files to the AWS_S3_BUCKET...'
                            sh "aws s3 cp ${APP_ZIP} s3://${S3_BUCKET}/"
                            sh "aws s3 cp ${LAYER_ZIP} s3://${S3_BUCKET}/"

                            // Create Dynamodb only for first time to run pipeline...
                            // To run it first_time uncomment it...
                             
                            // Create Dynamodb_Table for Terraform state locking
                            // echo 'Creating Dynamodb_Table for Terraform state locking...'
                            // sh """
                            //     aws dynamodb create-table \
                            //     --table-name terraform-state-lock-table \
                            //     --attribute-definitions AttributeName=LockID,AttributeType=S \
                            //     --key-schema AttributeName=LockID,KeyType=HASH \
                            //     --provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5
                            // """
                            // Initializing Terraform
                            echo 'Initializing Terraform...'
                            // sh 'terraform init -migrate-state'
                            // sh 'terraform init -reconfigure'
                            sh 'terraform init -upgrade'
                            sh """
                                terraform apply -auto-approve \
                                -var 's3_key_app=${APP_ZIP}' \
                                -var 'source_code_hash_app=${fileHashApp}' \
                                -var 's3_key_layer=${LAYER_ZIP}' \
                                -var 'source_code_hash_layer=${fileHashLayer}'
                            """
                        }
                    }
                }
            }
        }

        stage('Post-Deployment Info') {
            agent {
                docker {
                    image 'hashicorp/terraform:1.5.7'
                    args '--user 0 --entrypoint="" --dns 8.8.8.8'
                }
            }
            steps {
                script {
                    withCredentials([
                        string(credentialsId: 'AWS_ACCESS_KEY_ID', variable: 'AWS_ACCESS_KEY_ID'),
                        string(credentialsId: 'AWS_SECRET_ACCESS_KEY', variable: 'AWS_SECRET_ACCESS_KEY')
                    ]) {
                        dir(env.TF_PATH) {
                            def apiGatewayUrl = sh(returnStdout: true, script: 'terraform output -raw api_gateway_url').trim()
                            echo "Deployment Complete! Your API Gateway URL: ${apiGatewayUrl}"
                        }
                    }
                }
            }
        }
    }

    post {
        always { echo 'Cleaning up...' }
        failure { echo 'Pipeline failed!' }
        success { echo 'Pipeline completed successfully!' }
    }
}

// pipeline {
//     agent any
//     environment {
//         AWS_ACCOUNT_ID="375299695019"
//         AWS_DEFAULT_REGION="us-east-1"
//         IMAGE_REPO_NAME="pdf_app_repo"
//         IMAGE_TAG="latest"
//         REPOSITORY_URI = "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/${IMAGE_REPO_NAME}"
//     }
   
//     stages {

//         // stage('Logging into AWS ECR') {
//         //     steps {
//         //         script {
//         //         sh "aws ecr get-login-password --region ${AWS_DEFAULT_REGION} | docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com"
//         //         }
                 
//         //     }
//         // }
        
//         // stage('Cloning Git') {
//         //     steps {
//         //         checkout([$class: 'GitSCM', branches: [[name: '*/main']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: '', url: 'https://github.com/ASAD1575/pdf_converter_app.git']]])     
//         //     }
//         // }
  
//         // // Building Docker images
//         // stage('Building image') {
//         //     steps{
//         //         script {
//         //             dockerImage = docker.build "${IMAGE_REPO_NAME}:${IMAGE_TAG}"
//         //         }
//         //     }
//         // }
   
//         // // Uploading Docker images into AWS ECR
//         // stage('Pushing to ECR') {
//         //     steps{  
//         //         script {
//         //             sh "docker tag ${IMAGE_REPO_NAME}:${IMAGE_TAG} ${REPOSITORY_URI}:$IMAGE_TAG"
//         //             sh "docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/${IMAGE_REPO_NAME}:${IMAGE_TAG}"
//         //         }
//         //     }
//         // }

//         stage('Terraform Init') {
//             agent {
//                 docker {
//                     image 'hashicorp/terraform:1.5.7'
//                     args '--user 0 --entrypoint="" --dns 8.8.8.8'
//                 }
//             }
//             steps {
//                 script {
//                     withCredentials([
//                         string(credentialsId: 'AWS_ACCESS_KEY_ID', variable: 'AWS_ACCESS_KEY_ID'),
//                         string(credentialsId: 'AWS_SECRET_ACCESS_KEY', variable: 'AWS_SECRET_ACCESS_KEY')
//                     ]) {
//                         sh """
//                             terraform init -upgrade
//                             terraform apply -auto-approve
//                         """
//                     }
//                 }
//             }
//         }

//         stage('Post-Deployment Info') {
//             agent {
//                 docker {
//                     image 'hashicorp/terraform:1.5.7'
//                     args '--user 0 --entrypoint="" --dns 8.8.8.8'
//                 }
//             }
//             steps {
//                 script {
//                     withCredentials([
//                         string(credentialsId: 'AWS_ACCESS_KEY_ID', variable: 'AWS_ACCESS_KEY_ID'),
//                         string(credentialsId: 'AWS_SECRET_ACCESS_KEY', variable: 'AWS_SECRET_ACCESS_KEY')
//                     ]) {
//                         dir(env.TF_PATH) {
//                             def apiGatewayUrl = sh(returnStdout: true, script: 'terraform output -raw api_gateway_url').trim()
//                             echo "Deployment Complete! Your API Gateway URL: ${apiGatewayUrl}"
//                         }
//                     }
//                 }
//             }
//         }
//     }

//     post {
//         always { echo 'Cleaning up...' }
//         failure { echo 'Pipeline failed!' }
//         success { echo 'Pipeline completed successfully!' }
//     }
// }
